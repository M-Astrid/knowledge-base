<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Что такое побитовая операция AND?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D0%B0%D1%8F-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-and)
- [Пример на двоичных числах](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%BD%D0%B0-%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D1%85-%D1%87%D0%B8%D1%81%D0%BB%D0%B0%D1%85)
- [Почему важно "оба бита должны быть 1"?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B2%D0%B0%D0%B6%D0%BD%D0%BE-%D0%BE%D0%B1%D0%B0-%D0%B1%D0%B8%D1%82%D0%B0-%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B-%D0%B1%D1%8B%D1%82%D1%8C-1)
- [Итог](#%D0%B8%D1%82%D0%BE%D0%B3)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Что такое побитовая операция AND?

- Это операция, которая сравнивает соответствующие биты двух чисел.
- Для каждого бита берутся соответствующие биты из двух чисел.
- Результатом для каждого бита является `1` **только**, если оба исходных бита равны `1`.
- В противном случае результат — `0`.

---

## Пример на двоичных числах

Допустим, у нас есть два числа:

```
Число A: 0101  (в двоичной форме, это 5)
Число B: 0011  (в двоичной форме, это 3)
```

Проводим побитовое AND:

```
  0101
& 0011
-------
  0001
```

Пошагово:  
- 0 & 0 = 0  
- 1 & 0 = 0  
- 0 & 1 = 0  
- 1 & 1 = 1

Только в последней позиции оба бита равны 1, поэтому результат — `0001` (в десятичной — 1).

---

## Почему важно "оба бита должны быть 1"?

Потому что операция AND возвращает 1 **только** в случае, если оба бита равны 1.  
Это свойство позволяет:

- **Выделять или проверять наличие определённых флагов или признаков**, установленных в битах.

Например, если у вас есть флаги:

- `FLAG_A = 0001` (бит 0)
- `FLAG_B = 0010` (бит 1)
- `FLAG_C = 0100` (бит 2)

И у вас есть переменная `flags`, в которой установлены некоторые флаги:

```python
flags = 5  # в двоичной форме: 0101 (установлены FLAG_A и FLAG_C)
```

Чтобы проверить, установлен ли `FLAG_A` (`0001`):

```python
if flags & FLAG_A:
    print("FLAG_A установлен")
```

Потому что `flags & FLAG_A` даст `0001` — не ноль, значит флаг установлен.

---

## Итог

- **"Оба бита должны быть 1"** означает, что в результате побитового AND для соответствующих битов результат равен 1 только тогда, когда оба исходных бита равны 1.
- В остальных случаях результат — 0.

Это свойство делает операцию AND очень полезной для проверки наличия определённых флагов или признаков внутри числа.

---